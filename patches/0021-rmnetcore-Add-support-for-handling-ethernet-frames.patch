From 3ebbbbc54ea6ab2d65f937f6c683dcb6cabcd8c1 Mon Sep 17 00:00:00 2001
From: Kaustubh Pandey <quic_kapandey@quicinc.com>
Date: Sat, 11 May 2024 11:31:48 +0530
Subject: [PATCH 21/26] rmnetcore: Add support for handling ethernet frames

Added support for handling ethernet frames in UL and DL.

Change-Id: I1e44dcbde9d2dfb910e84eb54424f6735dd6e052
Signed-off-by: Kaustubh Pandey <quic_kapandey@quicinc.com>
---
 .../ethernet/qualcomm/rmnet/rmnet_config.c    | 23 +++++++++-
 .../ethernet/qualcomm/rmnet/rmnet_config.h    |  7 +++-
 .../ethernet/qualcomm/rmnet/rmnet_handlers.c  | 31 +++++++++-----
 .../net/ethernet/qualcomm/rmnet/rmnet_vnd.c   | 42 +++++++++++--------
 .../net/ethernet/qualcomm/rmnet/rmnet_vnd.h   |  4 +-
 5 files changed, 75 insertions(+), 32 deletions(-)

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index d068b4a4ccf8..80458b252fab 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /* Copyright (c) 2013-2018, The Linux Foundation. All rights reserved.
- * Copyright (c) 2023, Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2023-2024 Qualcomm Innovation Center, Inc. All rights reserved.
  *
  * RMNET configuration engine
  */
@@ -19,6 +19,8 @@
 
 enum {
 	IFLA_RMNET_QUEUE = __IFLA_RMNET_MAX,
+	IFLA_RMNET_TYPE,
+	IFLA_RMNET_QUEUE_NUM,
 	__IFLA_RMNET_EXT_MAX,
 };
 
@@ -26,6 +28,8 @@ static const struct nla_policy rmnet_policy[__IFLA_RMNET_EXT_MAX] = {
 	[IFLA_RMNET_MUX_ID]	= { .type = NLA_U16 },
 	[IFLA_RMNET_FLAGS]	= { .len = sizeof(struct ifla_rmnet_flags) },
 	[IFLA_RMNET_QUEUE]	= { .len = sizeof(struct rmnet_queue_mapping) },
+	[IFLA_RMNET_TYPE]       = { .len = NLA_U8},
+	[IFLA_RMNET_QUEUE_NUM]  = { .len = NLA_U8},
 };
 
 static int rmnet_is_real_dev_registered(const struct net_device *real_dev)
@@ -208,6 +212,8 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 	struct rmnet_port *port;
 	int err = 0;
 	u16 mux_id;
+	u8 type = RMNET_TYPE_WWAN;
+	u8 queue_num = 0;
 
 	if (!tb[IFLA_LINK]) {
 		NL_SET_ERR_MSG_MOD(extack, "link not specified");
@@ -226,15 +232,28 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 
 	mux_id = nla_get_u16(data[IFLA_RMNET_MUX_ID]);
 
+	if(!tb[IFLA_RMNET_TYPE]) {
+		NL_SET_ERR_MSG_MOD(extack, "RMNET type not specified");
+		goto register_dev;
+	}
+	type = nla_get_u8(data[IFLA_RMNET_TYPE]);
+
+	if (type == RMNET_TYPE_ETH) {
+		queue_num = nla_get_u8(data[IFLA_RMNET_QUEUE_NUM]);
+		netdev_dbg(dev, "queue num: %d\n", queue_num);
+	}
+
+register_dev:
 	err = rmnet_register_real_device(real_dev, extack);
 	if (err)
 		goto err0;
 
 	port = rmnet_get_port_rtnl(real_dev);
-	err = rmnet_vnd_newlink(mux_id, dev, port, real_dev, ep, extack);
+	err = rmnet_vnd_newlink(mux_id, dev, port, real_dev, ep, extack, type, queue_num);
 	if (err)
 		goto err1;
 
+	netdev_dbg(dev, "rmnet type %d\n", type);
 	err = netdev_upper_dev_link(real_dev, dev, extack);
 	if (err < 0)
 		goto err2;
diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.h b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.h
index e8ed06a3eaca..0d5d0b631b95 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.h
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /* Copyright (c) 2013-2014, 2016-2018, 2021 The Linux Foundation.
  * All rights reserved.
- * Copyright (c) 2023, Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2023-2024 Qualcomm Innovation Center, Inc. All rights reserved.
  *
  * RMNET Data configuration engine
  */
@@ -13,6 +13,8 @@
 #define _RMNET_CONFIG_H_
 
 #define RMNET_MAX_LOGICAL_EP 255
+#define RMNET_TYPE_ETH 1
+#define RMNET_TYPE_WWAN 0
 
 struct rmnet_endpoint {
 	u8 mux_id;
@@ -51,6 +53,7 @@ extern struct rtnl_link_ops rmnet_link_ops;
 struct rmnet_vnd_stats {
 	u64 rx_pkts;
 	u64 rx_bytes;
+	u64 rx_drops;
 	u64 tx_pkts;
 	u64 tx_bytes;
 	u32 tx_drops;
@@ -77,6 +80,8 @@ struct rmnet_priv_stats {
 
 struct rmnet_priv {
 	u8 mux_id;
+	u8 rmnet_type;
+	u8 queue_num;
 	struct net_device *real_dev;
 	struct rmnet_pcpu_stats __percpu *pcpu_stats;
 	struct gro_cells gro_cells;
diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index a313242a762e..ad02368ef80b 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -1,5 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /* Copyright (c) 2013-2018, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2024 Qualcomm Innovation Center, Inc. All rights reserved.
  *
  * RMNET Data ingress/egress handler
  */
@@ -7,6 +8,7 @@
 #include <linux/netdevice.h>
 #include <linux/netdev_features.h>
 #include <linux/if_arp.h>
+#include <linux/etherdevice.h>
 #include <net/sock.h>
 #include "rmnet_private.h"
 #include "rmnet_config.h"
@@ -21,16 +23,21 @@
 
 static void rmnet_set_skb_proto(struct sk_buff *skb)
 {
-	switch (skb->data[0] & 0xF0) {
-	case RMNET_IP_VERSION_4:
-		skb->protocol = htons(ETH_P_IP);
-		break;
-	case RMNET_IP_VERSION_6:
-		skb->protocol = htons(ETH_P_IPV6);
-		break;
-	default:
-		skb->protocol = htons(ETH_P_MAP);
-		break;
+	struct rmnet_priv* priv = netdev_priv(skb->dev);
+	if(priv->rmnet_type == RMNET_TYPE_ETH) {
+		skb->protocol = eth_type_trans(skb, skb->dev);
+	} else {
+		switch (skb->data[0] & 0xF0) {
+		case RMNET_IP_VERSION_4:
+			skb->protocol = htons(ETH_P_IP);
+			break;
+		case RMNET_IP_VERSION_6:
+			skb->protocol = htons(ETH_P_IPV6);
+			break;
+		default:
+			skb->protocol = htons(ETH_P_MAP);
+			break;
+		}
 	}
 }
 
@@ -136,6 +143,7 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 {
 	int required_headroom, additional_header_len, csum_type = 0;
 	struct rmnet_map_header *map_header;
+	struct rmnet_priv *priv = netdev_priv(orig_dev);
 
 	additional_header_len = 0;
 	required_headroom = sizeof(struct rmnet_map_header);
@@ -164,6 +172,9 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 
 	map_header->mux_id = mux_id;
 
+	if(priv->queue_num)
+		skb->queue_mapping = priv->queue_num;
+
 	skb->protocol = htons(ETH_P_MAP);
 
 	return 0;
diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index ce88ca702783..4424aa3ae08f 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -238,25 +238,8 @@ static const struct ethtool_ops rmnet_ethtool_ops = {
 void rmnet_vnd_setup(struct net_device *rmnet_dev)
 {
 	rmnet_dev->netdev_ops = &rmnet_vnd_ops;
-	rmnet_dev->mtu = RMNET_DFLT_PACKET_SIZE;
 	rmnet_dev->needed_headroom = RMNET_NEEDED_HEADROOM;
 	eth_hw_addr_random(rmnet_dev);
-	rmnet_dev->tx_queue_len = RMNET_TX_QUEUE_LEN;
-
-	/* Raw IP mode */
-	rmnet_dev->header_ops = NULL;  /* No header */
-	rmnet_dev->type = ARPHRD_RAWIP;
-	rmnet_dev->hard_header_len = 0;
-	rmnet_dev->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);
-
-	rmnet_dev->needs_free_netdev = true;
-	rmnet_dev->ethtool_ops = &rmnet_ethtool_ops;
-
-	rmnet_dev->features |= NETIF_F_LLTX;
-
-	/* This perm addr will be used as interface identifier by IPv6 */
-	rmnet_dev->addr_assign_type = NET_ADDR_RANDOM;
-	eth_random_addr(rmnet_dev->perm_addr);
 }
 
 /* Exposed API */
@@ -265,7 +248,9 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 		      struct rmnet_port *port,
 		      struct net_device *real_dev,
 		      struct rmnet_endpoint *ep,
-		      struct netlink_ext_ack *extack)
+		      struct netlink_ext_ack *extack,
+		      u8 type,
+		      u8 queue_num)
 
 {
 	struct rmnet_priv *priv = netdev_priv(rmnet_dev);
@@ -277,6 +262,25 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 		return -EBUSY;
 	}
 
+	if (type == RMNET_TYPE_ETH) {
+		ether_setup(rmnet_dev);
+	} else {
+		rmnet_dev->mtu = RMNET_DFLT_PACKET_SIZE;
+		rmnet_dev->tx_queue_len = RMNET_TX_QUEUE_LEN;
+		/* Raw IP mode */
+		rmnet_dev->header_ops = NULL;  /* No header */
+		rmnet_dev->type = ARPHRD_RAWIP;
+		rmnet_dev->hard_header_len = 0;
+		rmnet_dev->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);
+		rmnet_dev->needs_free_netdev = true;
+		rmnet_dev->ethtool_ops = &rmnet_ethtool_ops;
+		rmnet_dev->features |= NETIF_F_LLTX;
+		/* This perm addr will be used as interface i
+		dentifier by IPv6 */
+		rmnet_dev->addr_assign_type = NET_ADDR_RANDOM;
+		eth_random_addr(rmnet_dev->perm_addr);
+	}
+
 	rmnet_dev->hw_features = NETIF_F_RXCSUM;
 	rmnet_dev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
 	rmnet_dev->hw_features |= NETIF_F_SG;
@@ -299,6 +303,8 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 		rmnet_dev->rtnl_link_ops = &rmnet_link_ops;
 
 		priv->mux_id = id;
+		priv->rmnet_type = type;
+		priv->queue_num = queue_num;
 
 		xa_init(&priv->queue_map);
 
diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.h b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.h
index dc3a4443ef0a..5a3b6e58daba 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.h
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.h
@@ -1,5 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /* Copyright (c) 2013-2017, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2024 Qualcomm Innovation Center, Inc. All rights reserved.
  *
  * RMNET Data Virtual Network Device APIs
  */
@@ -12,7 +13,8 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 		      struct rmnet_port *port,
 		      struct net_device *real_dev,
 		      struct rmnet_endpoint *ep,
-		      struct netlink_ext_ack *extack);
+		      struct netlink_ext_ack *extack,
+		      u8 type, u8 queue_num);
 int rmnet_vnd_dellink(u8 id, struct rmnet_port *port,
 		      struct rmnet_endpoint *ep);
 void rmnet_vnd_rx_fixup(struct sk_buff *skb, struct net_device *dev);
-- 
2.45.2

